clc;
clear;
close all;

%% ============================================================
% FULL EKF-SLAM (Robot Pose + Landmark Map Estimation)
% State: [x y theta xL1 yL1 xL2 yL2 ...]'
% ============================================================

%% Simulation parameters
dt = 0.1;
N  = 250;

%% Control inputs
v = 1.0;
w = 0.08;

%% True landmark positions (UNKNOWN to filter)
landmarks_true = [ 5  10  15  20;
                  10   0  10  10];
numL = size(landmarks_true,2);

%% Noise covariances
R = diag([0.01 0.01 0.005]);   % Robot motion noise
Q = diag([0.3 0.05]);          % Measurement noise

%% Initial true robot state
x_true = [0; 0; 0];

%% Initial EKF-SLAM state (robot only)
u_0 = zeros(3 + 2*numL, 1); 

robot_pose_block = zeros(3, 3);
landmark_block = diag(ones(2*numL, 1) * 1e6); % Very high uncertainty 

Sigma_0 = blkdiag(robot_pose_block, landmark_block); % (3+2N)x(3+2N) matrix

%% Landmark initialization flag
landmark_initialized = false(1, numL);

%% Data storage
true_path = zeros(3,N);
est_path  = zeros(3,N);

%% ============================================================
% Main EKF-SLAM Loop
% ============================================================

y_t_1 = u_0;
Sigma_t_1 = Sigma_0;

I_1 = eye(3);
Z = zeros(3, 2*numL);
F_x = [I_1, Z];
R_new = F_x' * R * F_x;
I_2 = eye(3 + 2*numL);

for k = 1:N
    
        %% -------- TRUE ROBOT MOTION --------
    x_true = x_true + ...
        [v*dt*cos(x_true(3));
         v*dt*sin(x_true(3));
         w*dt];
    
        %% -------- EKF PREDICTION --------
              
    y_t_predicted = y_t_1 +  F_x' * [v*dt*cos(y_t_1(3));
                           v*dt*sin(y_t_1(3));
                           w*dt];
     
    p = [0 0 -v*dt*sin(y_t_1(3));
         0 0  v*dt*cos(y_t_1(3));
         0 0  0];
    G_t = I_2 + F_x' * p * F_x;
    Sigma_t_predicted = G_t * Sigma_t_1 * G_t' + R_new;
    
    %% -------- EKF UPDATE (FOR EACH LANDMARK) --------
    for i = 1:numL
        
        % True measurement
        dx = landmarks_true(1,i) - x_true(1);
        dy = landmarks_true(2,i) - x_true(2);
        r  = sqrt(dx^2 + dy^2);
        b  = atan2(dy, dx) - x_true(3);

        z = [r; b] + sqrt(Q)*randn(2,1);
        
        idx = 3 + 2*i - 1;   % Landmark index in state
        
        %% ---- Initialize landmark if unseen ----
        if ~landmark_initialized(i)
            u_jx = y_t_predicted(1) + z(1) * cos(z(2) + y_t_predicted(3));
            u_jy = y_t_predicted(2) + z(1) * sin(z(2) + y_t_predicted(3));
            
            y_t_predicted(idx) = u_jx;
            y_t_predicted(idx+1) = u_jy;
            
            landmark_initialized(i) = true;
            continue;
        end
        
        delta_x = y_t_predicted(idx) - y_t_predicted(1);
        delta_y = y_t_predicted(idx+1) - y_t_predicted(2);
        
        delta = [delta_x;
                 delta_y];
        q = delta' * delta;
        
        z_hat_i = 

        P1 = [eye(3); zeros(2, 3)];
        P2 = zeros(5, 2*i - 2);
        P3 = [zeros(3, 2); eye(2)];
        P4 = zeros(5, 2*N - 2*i);

        % Concatenate all parts 
        F_xj = [P1, P2, P3, P4];
        
        h_it = (1/q) * [ -sqrt(q)*delta_x, -sqrt(q)*delta_y,  0,   sqrt(q)*delta_x,  sqrt(q)*delta_y;
                          delta_y,         -delta_x,         -q,   -delta_y,         delta_x     ];
        H_it = h_it * F_xj;
        
        % Kalman gain
        S = Sigma_t_predicted * H_it' * inv(H_it * Sigma_t_predicted *  H_it' + Q);
        K = Sigma_t_predicted * H_it' * inv(H_it * Sigma_t_predicted *  H_it' + Q);
    
